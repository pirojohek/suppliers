# Suppliers Service

Сервис приёмки поставок и учёта цен поставщиков.

## Архитектура
- Hexagonal (ports & adapters):
  - `api`/`usecase` — приложение/домейн, сценарии без зависимостей от инфраструктуры.
  - `spi` — порты к инфраструктуре (JPA/Hibernate, внешние сервисы).
  - `storage` — адаптеры хранилища.
  - `spring webmvc` — входной адаптер (REST) + presentation DTO/мапперы.
- Зачем здесь hexagonal: поставка и отчёт — чисто доменные задачи (подбор цены по дате, фиксация фактов, агрегация по типам продукта). Изоляция домена позволяет:
  - легко менять входной слой (REST → gRPC) или хранилище (PostgreSQL → другая БД) без переписывания use case;
  - тестировать бизнес-логику без подъёма инфраструктуры;
  - гарантировать, что в домен не протекают детали сериализации/БД, а вход валидируется на границах.
- MapStruct — строгий и явный маппинг между слоями.
- Bean Validation + глобальный обработчик ошибок (ProblemDetail) — единый контракт ошибок и защита домена от мусорных данных.
- DTO разнесены: вход/выход не смешиваются с доменными моделями.

## Технологии
- Java 21, Spring Boot 3.5, Spring MVC, Spring Data JPA
- MapStruct 1.6.3 (генерация мапперов)
- Bean Validation (jakarta.validation)
- Mockito, JUnit для тестов
- Flyway (миграции БД)
- PostgreSQL (prod/runtime), H2 (тесты)
- Docker compose для развертывания БД
- springdoc-openapi (Swagger UI)

## База данных
- Реляционная модель в PostgreSQL: продукты, поставщики, цены поставщиков, поставки, позиции поставок.
- Цены поставщиков хранятся с периодами действия (`date_from`/`date_to`) — позволяет на дату приёмки выбрать актуальную цену даже если будущие цены уже изменены.
- Поставки и позиции фиксируют фактическую цену на момент приёмки (денормализация цены в позицию), чтобы история не менялась при обновлении прайс-листов.
- Нормализация: продукты и поставщики — отдельные сущности, позиции поставки ссылаются на продукт и содержат вес/цену/стоимость; отчёты агрегируют по типам продукта и поставщикам.
- Миграции: `src/main/resources/db/migration/V26_1_1_1__init.sql`.

## Запуск локально
Предварительно установите:
- Java 21
- Docker (для PostgreSQL) и Docker Compose
- Git (для клона), Maven не обязателен — есть `./mvnw`

Шаги:
```bash
# 1) Запустить PostgreSQL
cd src/main/resources/docker
docker compose up -d

# 2) Собрать приложение
cd ../../..
./mvnw clean package -DskipTests

# 3) Запустить
java -jar target/suppliers-0.0.1-SNAPSHOT.jar
```
Конфиг по умолчанию — `src/main/resources/application.yaml`. При другом окружении задайте:
```
SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/suppliers
SPRING_DATASOURCE_USERNAME=postgres
SPRING_DATASOURCE_PASSWORD=postgres
```
Для быстрого эксперимента можно переключить профиль на H2 в yaml.

## API и документация
- Swagger UI: `http://localhost:8080/swagger-ui.html`
- Основные эндпоинты (REST):
  - Продукты: создание `/api/products` (POST), получение `/api/products/{id}`, список с ценами на дату `/api/products/detailed?date=YYYY-MM-DD`
  - Поставщики: создание `/api/supplier` (POST)
  - Цены поставщиков: `/api/supplier-price` (POST)
  - Поставки: приёмка `/api/accept-supply` (POST), детали `/api/supply/{id}` (GET)
  - Отчёт: `/api/report/supplier-product?from=YYYY-MM-DD&to=YYYY-MM-DD`
- Контракты задокументированы через OpenAPI-аннотации; ошибки — `ProblemDetail` (400/404/500) с деталями валидации.

## Почему такая архитектура
- Hexagonal — изоляция домена: можно развивать отчёты и логику выбора цен, не трогая API/БД.
- MapStruct — явный контракт между слоями, меньше «магии» и регрессий.
- Bean Validation — защита на входе; ProblemDetail — единый формат ошибок для клиентов.
- Отдельное хранение цен и фактов поставок — корректная история и отчётность при изменении будущих цен.

## Кратко о реализации кейса
- Приёмка: POST `/api/accept-supply` принимает поставщика, дату, список товаров с весом; для цены берётся актуальная на дату поставки.
- Отчёт: GET `/api/report/supplier-product` агрегирует по поставщикам и типам продукта за период, возвращает итоговый вес и стоимость.

## Тесты
- Юнит/интеграционные тесты в `src/test/java/...`. Для MockMvc/валидации: `./mvnw test`.
